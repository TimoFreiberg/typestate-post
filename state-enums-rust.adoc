= Towards the Typestate Pattern in Rust: Algebraic Data Types
:source-highlighter: highlightjs
:highlightjs-languages: rust

Types are usually used to distinguish different data, or the same data, but in a different representation.
But when data can be in several different states, it can be advantageous to give each state its own type.

Let's take a look at an artificial example, introduce types for each state and see how this changes the code.

We'll also take the opportunity to compare Rust with Kotlin.
This post will show a Rust implementation and a future post will compare it with a Kotlin implementation.

== An example data type with many different states

Let's say our app manages the orders of a bicycle repair shop.
The main data structure of this app is the `RepairOrder`.
The Order can be in states like "repair in progress", "waiting for payment" or "paid and archived".

A very straightforward implementation could just distinguish between states using booleans and store all data that is ever needed in the same data type.

.1: Lots of simple types

This is the data type:

[source,rust]
----
struct RepairOrder {
    order_number: u64,
    damage_description: Option<String>,
    vehicle: String,
    customer: Customer,
    valid: Option<bool>,
    validation_errors: Vec<String>,
    assigned_technician: Option<Employee>,
    in_progress: bool,
    steps_left: Vec<String>,
    paid: bool,
    invoice: Option<String>,
}
----

and this is the function that implements the main workflow:

[source,rust]
----
fn process(mut order: RepairOrder) {
    if validate(&order) {
        order.valid = Some(true);
    } else {
        order.valid = Some(false);
        order.validation_errors = validation_errors(&order);
        store_invalid_order(order);
        return;
    }

    assert_eq!(order.valid, Some(true));

    let free_technician = find_idle_technician();
    order.assigned_technician = Some(free_technician);

    order.in_progress = true;

    order.steps_left = calculate_steps();

    while !order.steps_left.is_empty() {
        work_on_next_step(&mut order);
    }

    assert!(order.steps_left.is_empty());

    let invoice = send_invoice(&order);
    order.invoice = Some(invoice);

    await_payment();
    order.paid = true;

    assert!(order.paid);
}
----

While all actual work is done in the other functions that are referenced from the main `process` function, all state transitions are visible.

.Cons

This approach has many weaknesses (it is the 'before' in this 'before/after', after all):

* it's not very obvious how many possible states there are
** One per boolean? 2^number_of_booleans?
* the reader has to look at the logic where the data is used to see which states are possible and which data is used when
* it is technically possible for the data to be in an invalid state
** like `!valid && inProgress`, is that legal?
** and for the edge case hunters: Is it correct that `inProgress` stays `true` when the work is done and the billing process starts?
* some fields only apply to some states (the `invoice` field only becomes relevant when the work is finished, but is always available)

So when working with this grab-bag of variables there's probably a higher chance of overlooking bugs.

.Pros

* If all variable combinations are actually used, this is the easiest implementation.
* If I had to start writing code only knowing what data exists, but not really what states will realistically exist, I might start with this kind of implementation and hope to refactor it in the future.

=== 2: State as enums/sealed classes

Representing states with enums (sealed classes in Kotlin) would make it more obvious how many states there really are, which was not very obvious in the first version.
Let's enumerate the possible states from the first version:

|===
|State |Associated Data |Comment

|New |- |-
|Valid |- |-
|Invalid |validationErrors |Process will be aborted in this case
|InProgress |assignedTechnician, stepsLeft |-
|WorkDone |- |-
|WaitingForPayment |Invoice |-
|Paid |Invoice |Order is archived now
|===

==== Data Structures

A data structure like the following can encode the state using C-style enums:

[source,rust]
----
pub struct RepairOrder {
    pub order_number: u64,
    pub damage_description: Option<String>,
    pub vehicle: String,
    pub customer: Customer,
    pub state: OrderState
    pub validation_errors: Vec<String>,
    pub assigned_technician: Option<Employee>,
    pub steps_left: Vec<String>,
    pub invoice: Option<String>,
}
pub enum OrderState {
    New, Valid, Invalid, InProgress, WorkDone, WaitingForPayment, Paid
}
----

But we would like to also solve the issue that several fields are only relevant in some states.
To do this, we can move those fields from `RepairOrder` into the relevant states using ~algebraic data types~

[source,rust]
----
pub struct RepairOrder {
    pub order_number: u64,
    pub damage_description: Option<String>,
    pub vehicle: String,
    pub customer: Customer,
    pub state: OrderState
}
pub enum OrderState {
    New,
    Valid,
    Invalid { validation_errors: Vec<String> },
    InProgress {
        assigned_technician: Employee,
        steps_left: Vec<String>
    },
    WorkDone,
    WaitingForPayment { invoice: String },
    Paid { invoice: String }
}
----

Ah, looks cleaner already.

==== Functions

The function implementations change a little.
We're gonna avoid a big block of procedure this time and will have moved each step into a method.
We're also only going to look at two functions, the entire example code is linked at the end.

.Validate Function

[source,rust]
----
impl RepairOrder {
    //...
    fn validate(&mut self) {
        self.state = if is_valid() {
            State::Valid
        } else {
            let validation_errors = get_validation_errors();
            State::Invalid { validation_errors }
        };
    }
    //...
}
----

This one only gets more descriptive compared to the initial version, which is helped by the fact that it doesn't validate the initial state.
Similar to Kotlin, most things in Rust are expressions, which means that an `if`-block can be used in the right-hand-side of an assignment.

.Work Function

[source,rust]
----
    //...
    fn work(&mut self) {
        while {
            let steps_left = match &self.state {
                State::InProgress { steps_left, .. } => steps_left,
                other => panic!("Expected InProgress, but was {:?}", other),
            };
            !steps_left.is_empty()
        } {
            self.work_on_next_step()
        }
    //...
----

Here, the current state actually has to be `InProgress` for the function to work, and handling that is a bit more complex.

The unusual `while { ... } { ... }` part is just your average `while`-loop with a block returning the boolean.
Unlike Kotlin, in Rust it's always possible to open a new block which evaluates to its last expression.

.Thanks borrow checker

You might think that it would be nicer to extract the `steps_left` binding above the loop, at least that's what I thought.
But doing that actually leads to a compiler error!
That's because it would mean that part of `self` (namely `state`) is referenced (or borrowed) while `self.work_on_next_step()` is free to mutate `self` (like `state`)!

Rust, due to its lack of a GC, immediately frees unused memory.
Changing `state` in `work_on_next_step` to e.g. `State::WorkDone` would free the memory where the `steps_left` inside `State::InProgress` war previously.
The next loop would then once again attempt to check the emptiness of the `steps_left` it still has a reference to.
This would be a use after free, which Rust thankfully prevents.

But even if this wasn't forbidden, like in a garbage-collected language, the refactoring that Rust prevented could lead to the exact same problem scenario.
Thankfully, this could only lead to endless loops, but even those are still frowned upon.
I'll show this in the upcoming post about translating this into Kotlin.

.Pros

* It's immediately visible how many states there are.
* Only one state can be active at once
* States don't have access to data of other states.
* We can now make fields like `assigned_technician` mandatory, which wasn't possible in the previous approach!

.Con

* Accessing the expected state is a bit cumbersome.

If this con seems like a drawback of adding type explicitness, let me make the case for going even further:

== The case for going even further: The typestate pattern

This algorithm was contrived to be a linear state machine, so the human reader can always see what the expected state at each line of the program will be.
Any effort required to verify that the expected state is in fact stored in the `state` field can feel like annoying overhead that the type checker is forcing upon the human.

But much of this overhead came from the power to always change the `state` at any time - which wasn't even needed!
The design would be just as correct, and even more specific, if `validate` accepted a `NewRepairOrder` and returned a `Result<ValidRepairOrder, InvalidRepairOrder>` (you can probably imagine what those types would look like).
This is in fact a close approximation of what I'm going to show in the next blog post.

