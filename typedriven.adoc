= Type-driven programming
encoding information in types.

We often use the same type in different contexts -> we know more information about the current value than its type
Examples:
* A String can be a UserId, an Email, an error message, ...
* FilePaths can be relative or absolute and can point to directories or files (or just arbitrary strings)
* A doSomething-request in our web backend can be just received or already validated

There's a range of type safety, from dynamic and weakly typed programming languages, stringly typed programming in static languages all the way to https://www.idris-lang.org/[Idris] and formal verification.
I'm going to talk about some ways to increase type-safety that I still find practical (and maybe show some impractical things too).

Why (static) type-safety: (TODO probably remove this)
While writing, programmers usually have an idea what type each value will have.
Sometimes, people make mistakes and encounter a type error.
Statically typed languages show the error before the software is ever run, which can be helpful.

Sometimes we encode part of the information in types, but rarely all of it.
(alt?) Most of the time, we don't put every bit of information in the types.
For example, while we might give specific string types descriptive names like `UserId`, we're usually fine with giving a field like `isVerified` the type `boolean` (which https://github.com/quchen/articles/blob/master/algebraic-blindness.md[can lead to the "boolean blindness" problem])

Some widely accepted ways of moving information into types are:
* Using descriptive String wrappers to make type signatures more understandable and prevent mixing up e.g. `UserId` and `Email`.
* Using enums instead of Strings/Integers to constrain the set of possible values and give each a name.
* Using different types for the values retrieved from the database and the data received or returned in the API.footnote:[This also helps decouple the database schema and the API structure. This might even be the primary reason for using separate types, but it also prevents accidentally storing the request values in the database.]
* TODO more?

There are a few different reasons to give values their own type:

* Values like `Email`, `AccessToken`, (TODO more examples from a different domain please?) which might not be used in very complex logic (probably just stored/printed/sent/compared with other values of the same type)
  Here, types mostly help documenting the code and prevent mixing up completely different things.
  This approach is relatively common and uncontroversial.
  It also has no inherent drawbacks (meaning it's never wrong to constrain an email value to being an `Email`)
  In practice though, there's some overhead involved depending on the programming language.
footnote:[Compared to Java, Kotlin makes it much easier to cheaply declare String wrappers via the https://kotlinlang.org/docs/reference/data-classes.html[`data class`] feature.]
* Making

== Separate types for important states

The difference between

```rust
fn handle_request(request: Request) {
    if validate(&request) {
        do_something_with(request);
    } else {
        log_error(request);
    }
}
```

and

```rust
fn handle_request(request: Request) {
    match validate(request) {
        Ok(validated) => do_something_with(validated),
        Err(validation_error) => log_error(validation_error)
    }
}
```

is explained in Alexis King's post https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/

The type-driven approach not only makes the codebase safer by making it a type error to skip the validation step, it also helps in documenting the codebase a bit (I'm not saying that type signatures are enough documentation though).

Compare

```rust
fn do_something_with(request: Request) {...}
```

with

```rust
fn do_something_with(request: ValidatedRequest) {...}
```

The second version makes it explicit that validation needs to come first.

This approach can also help in design.
A common issue (mentioned in the "Parse, don't validate" article) is that fragments of validation logic are littered throughout the codebase wherever it occured to the developer or wherever the necessary data was available

Example: request validation first, then checking for conflicts in the database way later, then checking with another backend even later...
Counter: How to handle a case like this with the proposed approach? TODO

Rest:
Type variables instead of different types
Path showcase
bike repair shop?
* Repair request
** validate request integrity
** validate shop state
* Repair the bike
...

