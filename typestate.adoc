= Encoding state in types
:source-highlighter: highlightjs
:highlightjs-languages: rust, kotlin

Towards the typestate pattern, comparing Rust with Kotlin

Inspired by http://cliffle.com/blog/rust-typestate/ and https://chrisdone.com/posts/path-package/

== Representing different states of data in types

*TODO:* can I find any examples of this which are already commonly used?

Using separate request/logic/DB types is common, but used to decouple the data structure, not to encode different states in the type system (although that is also a nice benefit)

== Types with many different states

Let's say our app manages the orders of a bike repair shop.
There are some natural states for the order to be in, like "repair in progress" and "waiting for payment" or "paid and archived".

=== Lots of simple types

The most obvious implementation uses lots of booleans and stores all data of each state.

.Rust

A data structure like

[source,rust]
----
pub struct RepairOrder {
    pub order_number: u64,
    pub damage_description: Option<String>,
    pub vehicle: String,
    pub customer: Customer,
    pub valid: Option<bool>,
    pub validation_errors: Vec<String>,
    pub assigned_technician: Option<Employee>,
    pub in_progress: bool,
    pub steps_left: Vec<String>,
    pub paid: bool,
    pub invoice: Option<String>,
}
----

with a function like

[source,rust]
----
pub fn process(mut order: RepairOrder) {
    if validate(&order) {
        order.valid = Some(true);
    } else {
        order.valid = Some(false);
        order.validation_errors = validation_errors(&order);
        store_invalid_order(order);
        return;
    }

    assert_eq!(order.valid, Some(true));

    let free_technician = find_idle_technician();
    order.assigned_technician = Some(free_technician);

    order.in_progress = true;

    order.steps_left = calculate_steps();

    while !order.steps_left.is_empty() {
        work_on_next_step(&mut order);
    }

    assert!(order.steps_left.is_empty());

    let invoice = send_invoice(&order);
    order.invoice = Some(invoice);

    await_payment();
    order.paid = true;

    assert!(order.paid);
}
----

.Kotlin

A data structure like

[source,kotlin]
----
data class RepairOrder(
        val orderNumber: Long,
        val damageDescription: String?,
        val vehicle: String,
        val customer: Customer,
) {
    var valid: Boolean? = null
    var validationErrors: List<String> = emptyList()
    var assignedTechnician: Employee? = null
    var inProgress: Boolean = false
    var stepsLeft: MutableList<String> = mutableListOf()
    var paid: Boolean = false
    var invoice: String? = null
}
----

with a function like

[source,kotlin]
----
fun process(order: RepairOrder) {
    if (order.isValid()) {
        order.valid = true
    } else {
        order.valid = false
        order.validationErrors = order.validationErrors()
        return
    }
    assert(order.valid == true)

    val technician = findIdleTechnician()
    order.assignedTechnician = technician

    order.inProgress = true

    order.stepsLeft = calculateSteps(order)
    while (order.stepsLeft.isNotEmpty()) {
        workOnNextStep(order)
    }
    assert(order.stepsLeft.isEmpty())

    val invoice = sendInvoice(order)
    order.invoice = invoice

    awaitPayment()
    order.paid = true

    assert(order.paid)
}
----

.Language Comparison


In Kotlin, mutability is specified once in the class definition, which means that every public `var` or `MutableList` can be mutated from everywhere. +
In Rust, every public field can be mutated when given ownership or a mutable reference - but when given an immutable reference, none of these fields can be mutatedfootnote:[Except when using https://doc.rust-lang.org/book/ch15-05-interior-mutability.html[interior mutability]].

In Kotlin, default values for fields can be specified at the declaration. In the above example, the fields with default values can't be set in the constructor while the other fields have to be set. +
In Rust, there is exactly one wayfootnote:[https://doc.rust-lang.org/book/ch05-01-defining-structs.html] to initialize a struct: set every field. The idiomatic way to set default fields while still taking mandatory fields is a `RepairOrder::new` functionfootnote:[https://doc.rust-lang.org/std/keyword.struct.html#instantiation], which takes the first four arguments and sets the other arguments itself.

.Pros/Cons of this approach

This approach has many weaknesses:

* it's not very obvious how many possible states there are
** One per boolean? 2^number_of_booleans?
* it is technically possible for the data to be in an invalid state (like `!valid && inProgress`).
** Is it correct that `inProgress` stays `true` when the work is done and the billing process starts?
* some fields only apply to some states (the `invoice` field only becomes relevant when the work is finished, but is always available)
* all this needs to be handled correctly by the application logic and tested -> higher risk of overlooking bugs

Pros:

* If all variable combinations are actually used, this is the easiest implementation.
* If I know what data exists, but not really what states will realistically exist, I would probably start with this kind of implementation.

=== State as enums

Representing states with enums would make it more obvious how many states there really are, which was not very obvious in the first version. Let's enumerate them here:

|===
|State |Associated Data |Comment

|New |- |-
|Valid |- |-
|Invalid |validationErrors |Process will be aborted in this case
|InProgress |assignedTechnician, stepsLeft |-
|WorkDone |- |This state is not really required, InProgress can continue to WaitingForPayment immediately
|WaitingForPayment |Invoice |-
|Paid |Invoice |Order is archived now
|===

.Rust

A data structure like the following can encode the state:

[source,rust]
---
pub struct RepairOrder {
    pub order_number: u64,
    pub damage_description: Option<String>,
    pub vehicle: String,
    pub customer: Customer,
    pub state: OrderState
    pub validation_errors: Vec<String>,
    pub assigned_technician: Option<Employee>,
    pub steps_left: Vec<String>,
    pub invoice: Option<String>,
}
pub enum OrderState {
    New, Valid, Invalid, InProgress, WorkDone, WaitingForPayment, Paid
}
---

and, using C-style enums, would be directly translatable to Java and Kotlin.

But we would like to also solve the issue that several fields are only relevant in some states.
To do this, we can move those fields from `RepairOrder` into the relevant states.

[source,rust]
---
pub struct RepairOrder {
    pub order_number: u64,
    pub damage_description: Option<String>,
    pub vehicle: String,
    pub customer: Customer,
    pub state: OrderState
}
pub enum OrderState {
    New,
    Valid,
    Invalid { validation_errors: Vec<String> },
    InProgress {
        assigned_technician: Employee,
        steps_left: Vec<String>
    },
    WorkDone,
    WaitingForPayment { invoice: String },
    Paid { invoice: String }
}
---

Ah, looks cleaner already.

The same thing can be done in Kotlin with https://kotlinlang.org/docs/reference/sealed-classes.html[sealed classes]:

[source,kotlin]
---
data class RepairOrder(
        val orderNumber: Long,
        val damageDescription: String?,
        val vehicle: String,
        val customer: Customer,
        var state: State = State.New,
)
sealed class State {
    object New : State()
    object Valid : State()
    class Invalid(val validationErrors: List<String>) : State()
    class InProgress(val assignedTechnician: Employee, val stepsLeft: MutableList<String>) : State()
    object WorkDone : State()
    class WaitingForPayment(val invoice: String) : State()
    class Paid(val invoice: String) : State()
}
---

The function implementation doesn't change a whole lot. Many steps become more descriptive, unpacking the state-specific fields becomes a bit more verbose though.
TODO do I want to show the implementations here?

.Language Comparison

Fieldless subtypes of a sealed class in Kotlin are more verbose than fieldless enum values in Rust.

Casting/handling unknown instance type is easier in Kotlin than having methods that assume one enum value being set in Rust. TODO

== DEPRECATED PART FROM HERE

.Grouping 

When a type has many states, you won't want to duplicate it for each state:

* DbUser
* NewUser
* ValidatedNewUser
* MergedUser
* can you think of more?

if only to not write the same user fields n times.
One way to deduplicate this would be to keep all common fields in one type and embed this type in all the variants:

```rust
struct CommonUserFields {
    name: Option<UserName>,
    birthday: Option<Birthday>,
    email: Email,
    preferences: Preferences,
    ...
}

struct DbUser {
    id: RowId,
    fields: CommonUserFields,
}

struct NewUser {
    referral_token: Option<ReferralToken>,
    fields: CommonUserFields,
}

struct ValidatedNewUser {
    fields: CommonUserFields,
}
```

This is still a bit verbose, but less so than duplicating all the fields.

Another way to express this is often called the typestate pattern.

== Different user states using the typestate pattern

```rust
struct User<S> {
    name: Option<UserName,
    birthday: Option<Birthday>,
    email: Email,
    preferences: Preferences,
    state: S,
}

struct Db {
    id: RowId
}
// the same type names can be used via type aliases:
type DbUser = User<Db>;
// or not
fn storeUser(User<Validated>) -> Result<User<Db>, DbError> { todo!() }

struct New(Option<ReferralToken);
type NewUser = User<New>;
fn create_user(new_user: NewUser) -> Result<DbUser, CreateUserError> { todo!() }
```

== An example of the typestate pattern

It basically consists of expressing some state of the type with a type variable.
Compare:

```rust
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}
struct TrafficLights {
    color: TrafficLightColor,
}
impl TrafficLights {
    fn color(&self) -> TrafficLightColor { &self.color }
    fn is_red(&self) -> bool { self.color == TrafficLightColor::Red }
    fn is_yellow(&self) -> bool { self.color == TrafficLightColor::Yellow }
    fn is_green(&self) -> bool { self.color == TrafficLightColor::Green }
    fn turn_red(&mut self) {
        if self.is_yellow() {
            self.color = TrafficLightColor::Red
        } else {
            panic!("this should really return a Result<(), SomeError>!")
        }
    }
    // turn_yellow and turn_green is left as an exercise to the reader
}
```

with

```rust
// the colors are not namespaced here.
// if that's important, the names of the structs can be changed
// or the struct definitions can be moved into a `mod traffic_light_colors {}`
struct Red;
struct Yellow;
struct Green;
struct TrafficLights<C> {
    color: C,
}
impl TrafficLights<Yellow> {
    fn turn_red(self) -> TrafficLights<Red> {
        Self { color: Red }
    }
}
```

some differences in the API are necessary here.
It's no longer possible to mutate a yellow traffic light into a red traffic light, so the mutable API is no longer possible.
The first TrafficLights version could have also offered the functional API `fn turn_red(self) -> Self`, so here the version that uses the typestate pattern has less available options.
On the other hand, the turn_red function is now infallible as it can only be called with traffic lights that are in the correct state.

Another difference is that checking the current color of a traffic light whose state is unknown looks completely different.
In the initial version, writing `fn is_red<T>(tl: &TrafficLights<T>) -> bool` is actually not possible is it would require runtime reflection, which doesn't exist in rust (FIXME is this a correct description of the problem?)

cool bear style aside: what would the language need to offer to implement `fn is_red<T>(color: &T) -> bool`?

If I need to handle values in an unknown state but still want to use the typestate pattern, some additional machinery is required.
TODO do I want to show this?
